import { Text } from '@pixi/text';
import { Signal } from 'typed-signals';
import { Switcher } from './Switcher.mjs';
import { cleanup } from './utils/helpers/cleanup.mjs';
import { getView } from './utils/helpers/view.mjs';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CheckBox extends Switcher {
  constructor(options) {
    super();
    //* Text label */
    __publicField(this, "label");
    /** Signal emitted when checkbox state changes. */
    __publicField(this, "onCheck");
    __publicField(this, "_style");
    this.text = options.text;
    this.style = options.style;
    this.checked = options.checked;
    this.triggerEvents = ["onPress"];
    this.innerView.cursor = "pointer";
    this.onCheck = new Signal();
    this.onChange.connect(() => this.onCheck.emit(this.checked));
  }
  addLabel(text, style) {
    if (!text)
      return;
    this.label = new Text(text ?? "", style ?? this._style?.text);
    this.addChild(this.label);
    this.label.cursor = "pointer";
    this.label.eventMode = "static";
    this.label.on("pointertap", () => this.checked = !this.checked);
  }
  /** Setter, which sets a checkbox text. */
  set text(text) {
    if (!text) {
      cleanup(this.label);
      return;
    }
    this.label ? this.label.text = text : this.addLabel(text);
  }
  /** Getter, which returns a checkbox text. */
  get text() {
    return this.label?.text ?? "";
  }
  /** Setter, which sets a checkbox style settings. */
  set style(style) {
    const wasChecked = this.checked;
    this._style = style;
    const { unchecked, checked } = style;
    const uncheckedView = getView(unchecked);
    const checkedView = getView(checked);
    this.views = [uncheckedView, checkedView];
    if (wasChecked) {
      checkedView.visible = true;
      this.active = 1;
    } else {
      uncheckedView.visible = true;
    }
    if (this.label) {
      if (style.text)
        this.label.style = style.text;
      this.label.x = uncheckedView.width + 10 + (style.textOffset?.x ?? 0);
      this.label.y = (uncheckedView.height - this.label.height) / 2 + (style.textOffset?.y ?? 0);
    }
  }
  /** Getter, which returns a checkbox style settings. */
  get style() {
    return this._style;
  }
  /** Getter, which returns a checkbox state. */
  get checked() {
    return this.active === 1;
  }
  /** Setter, which sets a checkbox state. */
  set checked(checked) {
    this.switch(checked ? 1 : 0);
  }
  /**
   * Setter, that sets a checkbox state without emitting a signal.
   * @param checked
   */
  forceCheck(checked) {
    this.forceSwitch(checked ? 1 : 0);
  }
}

export { CheckBox };
//# sourceMappingURL=CheckBox.mjs.map
